// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import {SyntheticUSD} from "./SyntheticUSD.sol";
import {SyntheticEUR} from "./SyntheticEUR.sol";
import {SyntheticGBP} from "./SyntheticGBP.sol";
import {SyntheticJPY} from "./SyntheticJPY.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/mocks/ERC20Mock.sol";
import "../lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import {OracleLib} from "./libraries/OracleLib.sol";
import {ISyntheticToken} from "./interfaces/ISyntheticToken.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {TokenConfig} from "./TokenConfig.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Address.sol";

contract ForexEngineImproved is ReentrancyGuard, Ownable {
    using SafeMath for uint256;
    using Address for address;

    // Custom Errors
    error ForexEngine__NeedsMoreThanZero();
    error ForexEngine__TokenAddressesAndPriceFeedAddressedMustBeSameLength();
    error ForexEngine__SyntheticSymbolsAndAddressesMustMatchLength();
    error ForexEngine__NotAllowedToken();
    error ForexEngine__TransferFailed();
    error ForexEngine__MintFailed();
    error ForexEngine__NotAllowedZeroAddress();
    error ForexEngine__InvalidSyntheticSymbol();
    error ForexEngine__StalePrice();
    error ForexEngine__InvalidPrice();
    error ForexEngine__InsufficientMargin();
    error ForexEngine__PositionNotLiquidated();
    error ForexEngine__InvalidLeverage();
    error ForexEngine__ContractPaused();
    error ForexEngine__InvalidTokenAddress();
    error ForexEngine__CircuitBreakerTriggered();
    error ForexEngine__InvalidTpSlPrices();
    error NoOpenPosition();
    error PositionAlreadyClosed();
    error PriceNotAtTrigger();
    // Libraries

    using OracleLib for AggregatorV3Interface;

    // Constants
    uint256 private constant ADDITIONAL_FEED_PRECISION = 1e10;
    uint256 private constant PRECISION = 1e18;
    uint256 private constant BPS_DIVISOR = 10000;
    uint256 private constant MAX_STALENESS = 2 hours;

    uint256 public constant MAX_LEVERAGE = 5; // Max leverage: 5x
    uint256 public constant MIN_MARGIN_PERCENT = 30 * 100; // 30% in BPS
    uint256 public constant LIQUIDATION_BONUS = 50; // 0.5% in BPS
    uint256 public constant MIN_PRICE_MOVEMENT = 5; // 0.05% in BPS for TP/SL
    uint256 public priceTriggerBuffer = 5; // 0.05% in basis points
    uint256 public minLiquidationBuffer = 10; // 0.1% buffer for liquidations

    // State Variables
    int256 private s_totalProtocolPnl;
    bool private s_isPaused;
    bool private s_circuitBreakerTriggered;

    mapping(address => address) private s_priceFeeds;
    address[] private s_collateralTokens;

    mapping(address => mapping(address => uint256)) private s_collateralDeposited;
    mapping(string => address) private s_syntheticTokens;
    mapping(string => address) private s_syntheticPriceFeeds;

    mapping(address => uint256) private s_marginUsed;
    address[] private s_traderAddresses;
    mapping(address => bool) private s_isTrader;

    address private s_protocolReserve;
    mapping(address => mapping(string => uint256)) public s_userSyntheticExposure;
    string[] private s_syntheticSymbols;
    mapping(string => TokenConfig) public s_tokenConfig;

    struct Position {
        address user;
        string pair;
        bool isLong;
        uint256 entryPrice;
        uint256 marginUsed;
        uint256 leverage;
        uint256 tradeSize;
        uint256 timestamp;
        bool isOpen;
        uint256 exitPrice;
        int256 pnl;
        uint256 closeTimestamp;
        uint256 takeProfitPrice;
        uint256 stopLossPrice;
        uint256 liquidationPrice;
        uint256 size;
    }

    mapping(address => Position[]) private s_userPositions;
    mapping(address => int256) private s_realizedPnl;
    mapping(address => mapping(string => Position)) public userPositions;
    // Events

    event CollateralDeposited(address indexed user, address indexed token, uint256 amount);
    event CollateralRedeemed(address indexed from, address indexed to, address indexed token, uint256 amount);
    event PositionOpened(
        address indexed user,
        string pair,
        bool isLong,
        uint256 marginUsed,
        uint256 leverage,
        uint256 tradeSize,
        uint256 entryPrice,
        uint256 liquidationPrice
    );
    event PositionClosed(
        address indexed user,
        string pair,
        bool isLong,
        uint256 marginUsed,
        uint256 tradeSize,
        uint256 entryPrice,
        uint256 exitPrice,
        int256 pnl,
        uint256 timestamp
    );
    event ProtocolReserveSet(address indexed oldReserve, address indexed newReserve);
    event ProtocolProfitTaken(address indexed user, uint256 amount);
    event ProtocolLossCovered(address indexed user, uint256 amount);
    event UserLiquidated(address indexed user, uint256 timestamp, uint256 bonus);
    event TpSlTriggered(address indexed user, string pair, bool isLong, uint256 currentPrice, string reason);
    event CircuitBreakerTriggered(string reason);
    event CircuitBreakerReset();
    event ContractPaused();
    event ContractUnpaused();
    event TriggeredAutoClose(address indexed user, string symbol, string reason, uint256 price);

    // Modifiers
    modifier moreThanZero(uint256 amount) {
        if (amount == 0) revert ForexEngine__NeedsMoreThanZero();
        _;
    }

    modifier isAllowedToken(address token) {
        if (s_priceFeeds[token] == address(0)) {
            revert ForexEngine__NotAllowedToken();
        }
        _;
    }

    modifier whenNotPaused() {
        if (s_isPaused) revert ForexEngine__ContractPaused();
        _;
    }

    modifier whenNotCircuitBreaker() {
        if (s_circuitBreakerTriggered) {
            revert ForexEngine__CircuitBreakerTriggered();
        }
        _;
    }

    constructor(
        address[] memory tokenAddresses,
        address[] memory priceFeedAddresses,
        string[] memory syntheticSymbols,
        address[] memory syntheticTokenAddresses,
        TokenConfig[] memory syntheticConfigs,
        address[] memory syntheticPriceFeeds
    ) {
        if (tokenAddresses.length != priceFeedAddresses.length) {
            revert ForexEngine__TokenAddressesAndPriceFeedAddressedMustBeSameLength();
        }

        if (
            syntheticSymbols.length != syntheticTokenAddresses.length
                || syntheticSymbols.length != syntheticConfigs.length
                || syntheticSymbols.length != syntheticPriceFeeds.length
        ) {
            revert ForexEngine__SyntheticSymbolsAndAddressesMustMatchLength();
        }

        for (uint256 i = 0; i < tokenAddresses.length; i++) {
            _validateTokenAddress(tokenAddresses[i]);
            _validatePriceFeed(priceFeedAddresses[i]);
            s_priceFeeds[tokenAddresses[i]] = priceFeedAddresses[i];
            s_collateralTokens.push(tokenAddresses[i]);
        }

        for (uint256 j = 0; j < syntheticSymbols.length; j++) {
            string memory symbol = syntheticSymbols[j];
            _validateTokenAddress(syntheticTokenAddresses[j]);
            _validatePriceFeed(syntheticPriceFeeds[j]);

            s_syntheticTokens[symbol] = syntheticTokenAddresses[j];
            s_tokenConfig[symbol] = syntheticConfigs[j];
            s_syntheticPriceFeeds[symbol] = syntheticPriceFeeds[j];
            s_syntheticSymbols.push(symbol);
        }
    }

    // ========== Core Functions ==========

    function openPosition(
        string memory pair,
        bool isLong,
        uint256 marginAmount,
        uint256 leverage,
        uint256 takeProfitPrice,
        uint256 stopLossPrice
    ) external nonReentrant whenNotPaused whenNotCircuitBreaker {
        // Input validation
        if (leverage == 0 || leverage > MAX_LEVERAGE) {
            revert ForexEngine__InvalidLeverage();
        }
        if (marginAmount == 0) revert ForexEngine__NeedsMoreThanZero();

        // Get price feed and validate
        address feedAddr = s_syntheticPriceFeeds[pair];
        if (feedAddr == address(0)) {
            revert ForexEngine__InvalidSyntheticSymbol();
        }

        AggregatorV3Interface feed = AggregatorV3Interface(feedAddr);
        (, int256 entryPrice,, uint256 updatedAt,) = feed.latestRoundData();

        _validatePrice(entryPrice, updatedAt);

        // Calculate liquidation price
        uint256 liquidationPrice = _calculateLiquidationPrice(uint256(entryPrice), isLong, leverage);

        // Validate TP/SL prices
        if (takeProfitPrice > 0 || stopLossPrice > 0) {
            _validateTpSlPrices(uint256(entryPrice), takeProfitPrice, stopLossPrice, isLong);
        }

        // Check margin requirements
        _validateMarginRequirements(msg.sender, marginAmount, leverage);

        // Calculate trade size
        uint256 tradeSize = marginAmount.mul(leverage);

        // Verify synthetic token exists
        address sToken = s_syntheticTokens[pair];
        if (sToken == address(0)) revert ForexEngine__InvalidSyntheticSymbol();

        // Create position
        ISyntheticToken(sToken).mint(address(this), tradeSize);
        s_userSyntheticExposure[msg.sender][pair] = s_userSyntheticExposure[msg.sender][pair].add(tradeSize);

        s_userPositions[msg.sender].push(
            Position({
                user: msg.sender,
                pair: pair,
                isLong: isLong,
                entryPrice: uint256(entryPrice),
                marginUsed: marginAmount,
                leverage: leverage,
                tradeSize: tradeSize,
                timestamp: block.timestamp,
                isOpen: true,
                exitPrice: 0,
                pnl: 0,
                closeTimestamp: 0,
                takeProfitPrice: takeProfitPrice,
                stopLossPrice: stopLossPrice,
                liquidationPrice: liquidationPrice,
                size: 0
            })
        );

        // Update used margin (convert to USD)
        uint256 marginAmountUSD = _convertToUSD(s_collateralTokens[0], marginAmount);
        s_marginUsed[msg.sender] = s_marginUsed[msg.sender].add(marginAmountUSD);

        emit PositionOpened(
            msg.sender, pair, isLong, marginAmount, leverage, tradeSize, uint256(entryPrice), liquidationPrice
        );
    }

    function closePosition(uint256 index) external nonReentrant whenNotPaused {
        require(index < s_userPositions[msg.sender].length, "Invalid index");
        Position storage position = s_userPositions[msg.sender][index];
        require(position.isOpen, "Position already closed");

        _closePosition(msg.sender, index, false);
    }

    // ========== Collateral Management ==========

    function depositCollateral(address token, uint256 amount)
        external
        moreThanZero(amount)
        isAllowedToken(token)
        nonReentrant
        whenNotPaused
    {
        s_collateralDeposited[msg.sender][token] = s_collateralDeposited[msg.sender][token].add(amount);
        emit CollateralDeposited(msg.sender, token, amount);

        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);
        if (!success) revert ForexEngine__TransferFailed();
    }

    function redeemCollateral(address token, uint256 amount) external moreThanZero(amount) nonReentrant whenNotPaused {
        // Check margin requirements after redemption
        uint256 newBalance = s_collateralDeposited[msg.sender][token].sub(amount);
        uint256 newCollateralValue = _convertToUSD(token, newBalance);
        uint256 usedMargin = s_marginUsed[msg.sender];

        if (newCollateralValue.mul(BPS_DIVISOR) < usedMargin.mul(MIN_MARGIN_PERCENT)) {
            revert ForexEngine__InsufficientMargin();
        }

        s_collateralDeposited[msg.sender][token] = newBalance;
        emit CollateralRedeemed(msg.sender, msg.sender, token, amount);

        bool success = IERC20(token).transfer(msg.sender, amount);
        if (!success) revert ForexEngine__TransferFailed();
    }

    // ========== Risk Management ==========

    function checkAndLiquidate(address user) external nonReentrant {
        uint256 marginRatioBps = getUserMarginRatio(user);

        if (marginRatioBps >= MIN_MARGIN_PERCENT) {
            revert ForexEngine__PositionNotLiquidated();
        }

        Position[] storage positions = s_userPositions[user];
        uint256 len = positions.length;
        uint256 totalBonus = 0;

        for (uint256 i = 0; i < len; i++) {
            if (positions[i].isOpen) {
                totalBonus = totalBonus.add(_liquidatePosition(user, i));
            }
        }

        emit UserLiquidated(user, block.timestamp, totalBonus);
    }

    function _executeClose(address user, string memory symbol, uint256 executionPrice, string memory reason) internal {
        Position storage position = userPositions[user][symbol];

        // Update position state
        position.isOpen = false;
        position.exitPrice = executionPrice;
        position.closeTimestamp = block.timestamp;

        // Calculate PnL
        int256 priceDiff = position.isLong
            ? int256(executionPrice) - int256(position.entryPrice)
            : int256(position.entryPrice) - int256(executionPrice);
        position.pnl = (int256(position.size) * priceDiff) / int256(position.entryPrice);

        emit PositionClosed(
            user,
            symbol,
            position.isLong,
            position.marginUsed,
            position.size,
            position.entryPrice,
            executionPrice,
            position.pnl,
            block.timestamp
        );

        // Add this event emission
        emit TpSlTriggered(user, symbol, position.isLong, executionPrice, reason);
    }

    function checkTpSlAndClose(address user, string memory symbol) external nonReentrant {
        Position storage position = userPositions[user][symbol];
        if (position.size == 0) revert NoOpenPosition();
        if (!position.isOpen) revert PositionAlreadyClosed();

        // Get price in USD
        uint256 currentPrice = getDerivedPrice(symbol, "USD");
        uint256 adjustedPrice = _applyPriceBuffer(currentPrice, position.isLong);

        // Check TP/SL with buffer
        if (position.takeProfitPrice > 0 && adjustedPrice >= position.takeProfitPrice) {
            _executeClose(user, symbol, currentPrice, "TP");
            return; // Exit after successful close
        } else if (position.stopLossPrice > 0 && adjustedPrice <= position.stopLossPrice) {
            _executeClose(user, symbol, currentPrice, "SL");
            return;
        }
        // Check liquidation
        else if (_shouldLiquidate(position, currentPrice)) {
            _executeClose(user, symbol, currentPrice, "LIQ");
            return;
        }

        revert PriceNotAtTrigger();
    }

    function _applyPriceBuffer(uint256 price, bool isLong) internal view returns (uint256) {
        return isLong
            ? (price * (10_000 - priceTriggerBuffer)) / 10_000 // Long: Reduce price
            : (price * (10_000 + priceTriggerBuffer)) / 10_000; // Short: Increase price
    }

    function _shouldLiquidate(Position memory position, uint256 currentPrice) internal view returns (bool) {
        uint256 bufferAdjustedPrice = position.isLong
            ? (currentPrice * (10_000 + minLiquidationBuffer)) / 10_000
            : (currentPrice * (10_000 - minLiquidationBuffer)) / 10_000;

        return position.isLong
            ? bufferAdjustedPrice <= position.liquidationPrice
            : bufferAdjustedPrice >= position.liquidationPrice;
    }

    // ========== Admin Functions ==========

    function setSyntheticPriceFeed(string memory symbol, address newFeed) external onlyOwner {
        if (bytes(symbol).length == 0 || newFeed == address(0)) {
            revert ForexEngine__NotAllowedZeroAddress();
        }
        _validatePriceFeed(newFeed);
        s_syntheticPriceFeeds[symbol] = newFeed;
    }

    function setCollateralToken(address token, address priceFeed) external onlyOwner {
        if (token == address(0) || priceFeed == address(0)) {
            revert ForexEngine__NotAllowedZeroAddress();
        }
        _validateTokenAddress(token);
        _validatePriceFeed(priceFeed);

        s_priceFeeds[token] = priceFeed;

        // Add token to the array only if it's not already there
        bool exists = false;
        for (uint256 i = 0; i < s_collateralTokens.length; i++) {
            if (s_collateralTokens[i] == token) {
                exists = true;
                break;
            }
        }

        if (!exists) {
            s_collateralTokens.push(token);
        }
    }

    function setProtocolReserveWallet(address newReserve) external onlyOwner {
        if (newReserve == address(0)) {
            revert ForexEngine__NotAllowedZeroAddress();
        }
        address old = s_protocolReserve;
        s_protocolReserve = newReserve;
        emit ProtocolReserveSet(old, newReserve);
    }

    function triggerCircuitBreaker(string memory reason) external onlyOwner {
        s_circuitBreakerTriggered = true;
        emit CircuitBreakerTriggered(reason);
    }

    function resetCircuitBreaker() external onlyOwner {
        s_circuitBreakerTriggered = false;
        emit CircuitBreakerReset();
    }

    function pauseContract() external onlyOwner {
        s_isPaused = true;
        emit ContractPaused();
    }

    function unpauseContract() external onlyOwner {
        s_isPaused = false;
        emit ContractUnpaused();
    }

    function setPriceTriggerBuffer(uint256 newBuffer) external onlyOwner {
        priceTriggerBuffer = newBuffer;
    }

    // ========== Internal Functions ==========

    function _closePosition(address user, uint256 index, bool isLiquidation) internal returns (uint256) {
        Position storage position = s_userPositions[user][index];
        if (!position.isOpen) return 0;

        address feedAddr = s_syntheticPriceFeeds[position.pair];
        if (feedAddr == address(0)) {
            revert ForexEngine__InvalidSyntheticSymbol();
        }

        (, int256 exitPriceRaw,, uint256 updatedAt,) = AggregatorV3Interface(feedAddr).latestRoundData();
        _validatePrice(exitPriceRaw, updatedAt);
        uint256 exitPrice = uint256(exitPriceRaw);

        // Calculate PnL using safe int256 arithmetic
        int256 priceDiff = position.isLong
            ? int256(exitPrice) - int256(position.entryPrice)
            : int256(position.entryPrice) - int256(exitPrice);

        int256 pnl = (int256(position.tradeSize) * priceDiff) / int256(position.entryPrice);

        // Burn synthetic tokens
        address sToken = s_syntheticTokens[position.pair];
        if (sToken == address(0)) revert ForexEngine__InvalidSyntheticSymbol();
        require(position.tradeSize > 0, "Invalid trade size");
        ISyntheticToken(sToken).burn(position.tradeSize);
        s_userSyntheticExposure[user][position.pair] =
            s_userSyntheticExposure[user][position.pair].sub(position.tradeSize);

        // Convert margin used to USD and subtract
        uint256 marginUSD = _convertToUSD(s_collateralTokens[0], position.marginUsed);
        s_marginUsed[user] = s_marginUsed[user].sub(marginUSD);

        address baseToken = s_collateralTokens[0];
        uint256 bonusAmount = 0;

        if (pnl >= 0) {
            // Profit handling
            require(s_protocolReserve != address(0), "Reserve not set");
            uint256 profit = uint256(pnl);

            if (isLiquidation) {
                bonusAmount = profit.mul(LIQUIDATION_BONUS).div(BPS_DIVISOR);
                profit = profit.sub(bonusAmount);
            }

            bool success = IERC20(baseToken).transferFrom(s_protocolReserve, address(this), profit);
            if (!success) revert ForexEngine__TransferFailed();

            s_collateralDeposited[user][baseToken] = s_collateralDeposited[user][baseToken].add(profit);
            if (bonusAmount > 0) {
                s_collateralDeposited[msg.sender][baseToken] =
                    s_collateralDeposited[msg.sender][baseToken].add(bonusAmount);
            }

            emit ProtocolLossCovered(user, profit);
        } else {
            // Loss handling
            uint256 loss = uint256(-pnl);
            uint256 userBalance = s_collateralDeposited[user][baseToken];

            if (loss > userBalance) loss = userBalance;

            s_collateralDeposited[user][baseToken] = s_collateralDeposited[user][baseToken].sub(loss);

            if (isLiquidation) {
                bonusAmount = loss.mul(LIQUIDATION_BONUS).div(BPS_DIVISOR);
                loss = loss.sub(bonusAmount);
                s_collateralDeposited[msg.sender][baseToken] =
                    s_collateralDeposited[msg.sender][baseToken].add(bonusAmount);
            }

            IERC20(baseToken).transfer(s_protocolReserve, loss);
            emit ProtocolProfitTaken(user, loss);
        }

        // Update position state
        position.exitPrice = exitPrice;
        position.pnl = pnl;
        position.closeTimestamp = block.timestamp;
        position.isOpen = false;

        // Track unique traders
        if (!s_isTrader[user]) {
            s_isTrader[user] = true;
            s_traderAddresses.push(user);
        }

        // Fixed: Use native arithmetic for int256
        s_realizedPnl[user] = s_realizedPnl[user] + pnl;
        s_totalProtocolPnl = s_totalProtocolPnl - pnl;

        emit PositionClosed(
            user,
            position.pair,
            position.isLong,
            position.marginUsed,
            position.tradeSize,
            position.entryPrice,
            exitPrice,
            pnl,
            block.timestamp
        );

        return bonusAmount;
    }

    function _liquidatePosition(address user, uint256 index) internal returns (uint256) {
        return _closePosition(user, index, true);
    }

    function _validatePrice(int256 price, uint256 updatedAt) internal view {
        if (price <= 0) revert ForexEngine__InvalidPrice();
        if (block.timestamp > updatedAt && block.timestamp.sub(updatedAt) > MAX_STALENESS) {
            revert ForexEngine__StalePrice();
        }
    }

    function _validateTokenAddress(address token) internal view {
        if (token == address(0)) revert ForexEngine__NotAllowedZeroAddress();
        if (!token.isContract()) revert ForexEngine__InvalidTokenAddress();
    }

    function _validatePriceFeed(address feed) internal view {
        if (feed == address(0)) revert ForexEngine__NotAllowedZeroAddress();
        if (!feed.isContract()) revert ForexEngine__InvalidTokenAddress();

        try AggregatorV3Interface(feed).decimals() returns (uint8) {
            // Success
        } catch {
            revert ForexEngine__InvalidTokenAddress();
        }
    }

    function _validateMarginRequirements(address user, uint256 marginAmount, uint256 leverage) internal view {
        uint256 totalCollateralValue = _getTotalCollateralValue(user);
        uint256 requiredMargin = marginAmount.mul(leverage).mul(MIN_MARGIN_PERCENT).div(BPS_DIVISOR);

        if (totalCollateralValue < requiredMargin) {
            revert ForexEngine__InsufficientMargin();
        }
    }

    function _validateTpSlPrices(uint256 entryPrice, uint256 takeProfitPrice, uint256 stopLossPrice, bool isLong)
        internal
        pure
    {
        if (isLong) {
            if (takeProfitPrice > 0 && takeProfitPrice <= entryPrice) {
                revert ForexEngine__InvalidTpSlPrices();
            }
            if (stopLossPrice > 0 && stopLossPrice >= entryPrice) {
                revert ForexEngine__InvalidTpSlPrices();
            }
            if (stopLossPrice > 0 && takeProfitPrice > 0 && stopLossPrice >= takeProfitPrice) {
                revert ForexEngine__InvalidTpSlPrices();
            }
        } else {
            if (takeProfitPrice > 0 && takeProfitPrice >= entryPrice) {
                revert ForexEngine__InvalidTpSlPrices();
            }
            if (stopLossPrice > 0 && stopLossPrice <= entryPrice) {
                revert ForexEngine__InvalidTpSlPrices();
            }
            if (stopLossPrice > 0 && takeProfitPrice > 0 && stopLossPrice <= takeProfitPrice) {
                revert ForexEngine__InvalidTpSlPrices();
            }
        }
    }

    function _hasSufficientPriceMovement(uint256 entryPrice, uint256 currentPrice) internal pure returns (bool) {
        uint256 priceChange = currentPrice > entryPrice
            ? currentPrice.sub(entryPrice).mul(BPS_DIVISOR).div(entryPrice)
            : entryPrice.sub(currentPrice).mul(BPS_DIVISOR).div(entryPrice);

        return priceChange >= MIN_PRICE_MOVEMENT;
    }

    function _calculateLiquidationPrice(uint256 entryPrice, bool isLong, uint256 leverage)
        internal
        pure
        returns (uint256)
    {
        uint256 leverageFactor = PRECISION.div(leverage);
        uint256 marginBuffer = MIN_MARGIN_PERCENT.mul(PRECISION).div(BPS_DIVISOR);

        if (isLong) {
            return entryPrice.mul(PRECISION.sub(leverageFactor).add(marginBuffer)).div(PRECISION);
        } else {
            return entryPrice.mul(PRECISION.add(leverageFactor).sub(marginBuffer)).div(PRECISION);
        }
    }

    function _convertToUSD(address token, uint256 amount) internal view returns (uint256) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(s_priceFeeds[token]);
        (, int256 price,, uint256 updatedAt,) = priceFeed.latestRoundData();
        _validatePrice(price, updatedAt);

        uint8 tokenDecimals = ERC20(token).decimals();
        uint8 priceDecimals = priceFeed.decimals();

        return amount.mul(uint256(price)).mul(10 ** (18 - priceDecimals)).div(10 ** tokenDecimals);
    }

    function _getTotalCollateralValue(address user) internal view returns (uint256 totalValue) {
        for (uint256 i = 0; i < s_collateralTokens.length; i++) {
            address token = s_collateralTokens[i];
            uint256 amount = s_collateralDeposited[user][token];
            if (amount == 0) continue;

            totalValue = totalValue.add(_convertToUSD(token, amount));
        }
    }

    // ========== View Functions ==========

    function getUserMarginRatio(address user) public view returns (uint256 marginRatioBps) {
        // Calculate total collateral value in USD
        uint256 totalCollateralUsd = _getTotalCollateralValue(user);

        // Calculate used margin in USD
        uint256 usedMarginUsd = s_marginUsed[user];

        if (usedMarginUsd == 0) {
            return BPS_DIVISOR; // 100% margin ratio if no positions open
        }

        // Calculate unrealized PnL from open positions
        int256 totalUnrealizedPnl = 0;
        Position[] memory positions = s_userPositions[user];

        for (uint256 i = 0; i < positions.length; i++) {
            if (!positions[i].isOpen) continue;

            uint256 currentPrice = getDerivedPrice(positions[i].pair, "USD");
            uint256 entryPrice = positions[i].entryPrice;
            uint256 size = positions[i].tradeSize;

            if (positions[i].isLong) {
                totalUnrealizedPnl += (int256(size) * (int256(currentPrice) - int256(entryPrice))) / int256(entryPrice);
            } else {
                totalUnrealizedPnl += (int256(size) * (int256(entryPrice) - int256(currentPrice))) / int256(entryPrice);
            }
        }

        // Calculate equity (collateral + PnL)
        int256 equity = int256(totalCollateralUsd) + totalUnrealizedPnl;
        if (equity <= 0) {
            return 0; // Completely underwater
        }

        // Return margin ratio in basis points (e.g., 3000 = 30%)
        // Fixed: Convert all values to uint256 before division
        marginRatioBps = (uint256(equity) * BPS_DIVISOR) / usedMarginUsd;
    }

    function getDerivedPrice(string memory base, string memory quote) public view returns (uint256) {
        address baseFeed = s_syntheticPriceFeeds[base];
        address quoteFeed = s_syntheticPriceFeeds[quote];

        require(baseFeed != address(0), "Base feed not set");
        require(quoteFeed != address(0), "Quote feed not set");

        (, int256 basePrice,, uint256 baseUpdatedAt,) = AggregatorV3Interface(baseFeed).latestRoundData();
        (, int256 quotePrice,, uint256 quoteUpdatedAt,) = AggregatorV3Interface(quoteFeed).latestRoundData();

        _validatePrice(basePrice, baseUpdatedAt);
        _validatePrice(quotePrice, quoteUpdatedAt);

        // Handle decimals properly
        uint8 baseDecimals = AggregatorV3Interface(baseFeed).decimals();
        uint8 quoteDecimals = AggregatorV3Interface(quoteFeed).decimals();

        uint256 baseScaled = uint256(basePrice).mul(10 ** (18 - baseDecimals));
        uint256 quoteScaled = uint256(quotePrice).mul(10 ** (18 - quoteDecimals));

        return baseScaled.mul(PRECISION).div(quoteScaled);
    }

    function getSyntheticTokenAddress(string memory symbol) external view returns (address) {
        return s_syntheticTokens[symbol];
    }

    function getSyntheticPriceFeed(string memory symbol) external view returns (address) {
        return s_syntheticPriceFeeds[symbol];
    }

    function getCollateralBalance(address user, address token) external view returns (uint256) {
        return s_collateralDeposited[user][token];
    }

    function getTokenConfig(string memory symbol) external view returns (TokenConfig memory) {
        return s_tokenConfig[symbol];
    }

    function getPriceFeed(address token) external view returns (address) {
        return s_priceFeeds[token];
    }

    function getCollateralTokens() external view returns (address[] memory) {
        return s_collateralTokens;
    }

    function getProtocolReserveWallet() external view returns (address) {
        return s_protocolReserve;
    }

    function getTotalProtocolPnl() external view onlyOwner returns (int256) {
        return s_totalProtocolPnl;
    }

    function getRealizedPnl(address user) external view returns (int256) {
        return s_realizedPnl[user];
    }

    // ... [Additional view functions as needed]
}
